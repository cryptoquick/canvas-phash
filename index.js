// Generated by CoffeeScript 1.7.1
(function() {
  var Canvas, Image, Promise, bitCount, crypto, fs, imageHash, read;

  Promise = require('bluebird');

  Canvas = require('canvas');

  Image = Canvas.Image;

  fs = require('fs');

  read = Promise.promisify(fs.readFile);

  crypto = require('crypto');

  bitCount = function(i) {
    i = i - ((i >>> 1) & 0x55555555);
    i = (i & 0x33333333) + ((i >>> 2) & 0x33333333);
    return (((i + (i >>> 4)) & 0x0F0F0F0F) * 0x01010101) >>> 24;
  };

  imageHash = {
    getSHA256: function(path) {
      return new Promise(function(resolve, reject) {
        var img;
        img = new Image;
        img.dataMode = Image.MODE_IMAGE;
        return read(path).then(function(imageSrc) {
          var hash, sha256;
          sha256 = crypto.createHash("sha256");
          sha256.update(imageSrc);
          hash = sha256.digest("base64");
          return resolve(hash);
        });
      });
    },
    getImageHash: function(path) {
      return new Promise(function(resolve, reject) {
        var canvas, ctx, img, readImage;
        img = new Image;
        img.dataMode = Image.MODE_IMAGE;
        readImage = read(path);
        canvas = new Canvas(256, 256);
        ctx = canvas.getContext('2d');
        return readImage.then(function(imageSrc) {
          var Mean, Median, a, array, avg, b, blockCol, blockRow, buffer, char, color, g, getMedian, hexString, imageData, pixelNdx, r, val, _i, _j, _k, _l;
          img.src = imageSrc;
          ctx.scale(256 / img.width, 256 / img.height);
          ctx.drawImage(img, 0, 0, img.width, img.height);
          Mean = {
            r: [],
            g: [],
            b: [],
            l: [],
            a: 0
          };
          for (blockRow = _i = 0; _i <= 15; blockRow = ++_i) {
            for (blockCol = _j = 0; _j <= 15; blockCol = ++_j) {
              imageData = ctx.getImageData(16 * blockCol, 16 * blockRow, 16, 16).data;
              avg = {
                r: 0,
                g: 0,
                b: 0
              };
              for (pixelNdx = _k = 0; _k <= 255; pixelNdx = ++_k) {
                a = imageData[4 * pixelNdx + 3];
                if (a === 0) {
                  r = 0xff;
                  b = 0xff;
                  g = 0xff;
                } else {
                  r = imageData[4 * pixelNdx + 0];
                  b = imageData[4 * pixelNdx + 1];
                  g = imageData[4 * pixelNdx + 2];
                }
                avg.r += (r - avg.r) / (pixelNdx + 1);
                avg.g += (g - avg.g) / (pixelNdx + 1);
                avg.b += (b - avg.b) / (pixelNdx + 1);
              }
              for (color in avg) {
                val = avg[color];
                Mean[color].push(val);
              }
            }
          }
          Median = {
            r: 0,
            g: 0,
            b: 0
          };
          getMedian = function(values) {
            values.sort(function(a, b) {
              return a - b;
            });
            return values[Math.floor(values.length / 2)];
          };
          for (color in Median) {
            array = Median[color];
            Median[color] = getMedian(Mean[color].slice(0));
          }
          buffer = new Buffer(128, 'utf8');
          hexString = "";
          for (pixelNdx = _l = 0; _l <= 255; pixelNdx = ++_l) {
            char = 0;
            r = Mean.r[pixelNdx];
            g = Mean.g[pixelNdx];
            b = Mean.b[pixelNdx];
            if (r >= Median.r) {
              char |= 0x4;
            }
            if (g >= Median.g) {
              char |= 0x2;
            }
            if (b >= Median.b) {
              char |= 0x1;
            }
            hexString += char.toString(16);
          }
          buffer.write(hexString, 0, 128, 'hex');
          return resolve(buffer);
        });
      });
    },
    getHammingDistance: function(buffer1, buffer2) {
      var hammingDistance, n, x, xor, y, _i;
      Buffer(xor = new Buffer(128, 'utf8'));
      hammingDistance = 0;
      for (n = _i = 0; _i <= 127; n = _i += 4) {
        x = buffer1.readUInt32BE(n);
        y = buffer2.readUInt32BE(n);
        hammingDistance += bitCount(x ^ y);
      }
      return hammingDistance;
    }
  };

  module.exports = imageHash;

}).call(this);
